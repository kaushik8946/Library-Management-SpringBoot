package dev.kaushik.library.service.impl;

import dev.kaushik.library.dao.BookDAO;
import dev.kaushik.library.exception.LibraryException;
import dev.kaushik.library.model.Book;
import dev.kaushik.library.service.BookService;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.validation.annotation.Validated;

@Service
@Validated
public class BookServiceImpl implements BookService {
	private final BookDAO bookDAO;

	@Autowired
	public BookServiceImpl(BookDAO bookDAO) {
		this.bookDAO = bookDAO;
	}

	@Override
	public int addBook(@Valid @NotNull Book book) throws LibraryException {
		if (book.getBookId() != null) {
			throw new LibraryException("Book ID can not be specified, it will be autogenerated");
		}
		try {
			return bookDAO.addBook(book);
		} catch (DataAccessException e) {
			throw new LibraryException("Failed to add book: " + e.getMessage(), e);
		}
	}

	@Override
	public List<Book> findBooks(Book criteria) throws LibraryException {
		try {
			return bookDAO.findBooks(criteria);
		} catch (DataAccessException e) {
			throw new LibraryException("Failed to find books: " + e.getMessage(), e);
		}
	}

	@Override
	@Transactional
	public boolean updateBook(@Valid @NotNull Book book) throws LibraryException {
		if (book.getBookId() == null) {
			throw new LibraryException("Book ID must be provided for update.");
		}
		try {
			List<Book> existingBooks = bookDAO.findBooks(Book.builder().bookId(book.getBookId()).build());
			if (existingBooks.isEmpty()) {
				return false;
			}
			Book existingBook = existingBooks.get(0);
			if (existingBook.equals(book)) {
				throw new LibraryException("No changes were entered, same details found");
			}
			return bookDAO.updateBook(book);
		} catch (DataAccessException e) {
			throw new LibraryException("Failed to update book with ID: " + book.getBookId(), e);
		}
	}

	@Override
	@Transactional
	public boolean deleteBook(@NotNull @Positive Integer bookId) throws LibraryException {
		try {
			int deletedRows = bookDAO.deleteBooksInBatch(bookId);
			return deletedRows > 0;
		} catch (DataAccessException e) {
			throw new LibraryException("Failed to delete book with ID: " + bookId, e);
		}
	}

	@Override
	@Transactional
	public int deleteBooksBatch(@NotNull List<@NotNull @Positive Integer> bookIds) throws LibraryException {
		try {
			return bookDAO.deleteBooksInBatch(bookIds.toArray(new Integer[0]));
		} catch (DataAccessException e) {
			throw new LibraryException("Failed to delete books in batch", e);
		}
	}

	@Override
	@Transactional
	public int updateBookAvailabilityBatch(@NotNull List<@NotNull @Positive Integer> bookIds) throws LibraryException {
		try {
			return bookDAO.updateBookAvailabilityBatch(bookIds);
		} catch (DataAccessException e) {
			throw new LibraryException("Failed to update book availability in batch", e);
		}
	}
}