package dev.kaushik.library.service.impl;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import dev.kaushik.library.dao.BookDAO;
import dev.kaushik.library.exception.LibraryException;
import dev.kaushik.library.model.Book;
import dev.kaushik.library.model.IssueRecord;
import dev.kaushik.library.model.enums.IssueStatus;
import dev.kaushik.library.service.BookService;
import dev.kaushik.library.service.IssueService;
import dev.kaushik.library.validator.BookValidator;

@Service
public class BookServiceImpl implements BookService {
	private final BookDAO bookDAO;
	private final IssueService issueService;

	@Autowired
	public BookServiceImpl(BookDAO bookDAO, IssueService issueService) {
		this.bookDAO = bookDAO;
		this.issueService = issueService;
	}

	@Override
	public int addBook(Book book) {
		if (book == null) {
			throw new LibraryException("Book cant be null");
		}
		if (book.getBookId() != null) {
			throw new LibraryException("Book ID can not be specified, it will be autogenerated");
		}
		BookValidator.validate(book);
		List<Book> allBooks = bookDAO.findBooks(null);
		if (allBooks.stream().filter(b -> b.getTitle().equalsIgnoreCase(book.getTitle())).count() != 0) {
			throw new LibraryException("Book already Exists with title: " + book.getTitle());
		}
		return bookDAO.addBook(book);
	}

	@Override
	public List<Book> findBooks(Book criteria) throws LibraryException {
		return bookDAO.findBooks(criteria);
	}

	@Override
	public boolean updateBook(Book book) throws LibraryException {
		if (book == null) {
			throw new LibraryException("Book cant be null");
		}
		if (book.getBookId() == null) {
			throw new LibraryException("Book ID must be provided for update.");
		}
		BookValidator.validate(book);
		List<Book> allBooks = bookDAO.findBooks(null);

		Book existingBook = allBooks.stream().filter(b -> b.getBookId() == book.getBookId()).findFirst().orElse(null);
		if (existingBook == null) {
			throw new LibraryException("no Book Exists with Id: " + book.getBookId());
		}
		if (existingBook.equals(book)) {
			throw new LibraryException("No changes were entered, same details found");
		}
		if (allBooks.stream().filter(b -> b.getBookId() != book.getBookId())
				.filter(b -> b.getTitle().equalsIgnoreCase(book.getTitle())).count() != 0) {
			throw new LibraryException("Book already Exists with title: " + book.getTitle());
		}
		return bookDAO.updateBook(book);
	}

	@Override
	public boolean deleteBook(Integer bookId) throws LibraryException {
		if (bookId == null) {
			throw new LibraryException("book ID cant be null");
		}
		if (bookId <= 0) {
			throw new LibraryException("book Id should only be positive");
		}
		int deletedRows = bookDAO.deleteBooksInBatch(bookId);
		return deletedRows > 0;
	}

	@Override
	public int deleteBooksBatch(List<Integer> bookIds) throws LibraryException {
		if (bookIds == null) {
			throw new LibraryException("Book IDs cant be null");
		}
		bookIds.forEach(bookId -> {
			if (bookId == null) {
				throw new LibraryException("book ID cant be null");
			}
			if (bookId <= 0) {
				throw new LibraryException("book Id should only be positive");
			}
		});
		List<IssueRecord> allIssuedRecords = issueService.getAllIssuedRecords().stream()
				.filter(issueRecord -> issueRecord.getStatus() == IssueStatus.ISSUED).toList();
		List<Integer> matched = allIssuedRecords.stream()
				.filter(issueRecord -> bookIds.contains(issueRecord.getBookId())).map(i -> i.getBookId()).toList();
		if (matched.size() > 0) {
			throw new LibraryException("following Book Id's issued, so failed to delete " + matched);
		}
		return bookDAO.deleteBooksInBatch(bookIds.toArray(new Integer[0]));
	}

	
	@Override
	public int updateBookStatusBatch(List<Integer> bookIds) throws LibraryException {
		if (bookIds == null) {
			throw new LibraryException("Book IDs cant be null");
		}
		bookIds.forEach(bookId -> {
			if (bookId == null) {
				throw new LibraryException("book ID cant be null");
			}
			if (bookId <= 0) {
				throw new LibraryException("book Id should only be positive");
			}
		});
		List<Book> allBooks = bookDAO.findBooks(null);
		List<Integer> allBookIds = allBooks.stream().map(b -> b.getBookId()).toList();
		List<Integer> missingIds = bookIds.stream().filter(id -> !allBookIds.contains(id)).toList();
		if (missingIds.size() > 0) {
			throw new LibraryException("following Book Id's does not exist " + missingIds);
		}
		long count = allBooks.stream().filter(b -> bookIds.contains(b.getBookId())).map(b -> b.getStatus()).distinct()
				.count();
		if (count != 1) {
			throw new LibraryException("All selected books must have same status");
		}
		return bookDAO.updateBookStatusBatch(bookIds);
	}
}